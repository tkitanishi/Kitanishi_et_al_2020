% Rate map analysis of T-maze. Requires XXX_trialDef.mat file generated by
% ratemapT_triafDef.m.
% 
%   posaxis:    position axis (normalized, 0 to 1)
%   tMap:       time occupancy map (sec)
%   vMap:       velocity map (cm/s)
% 
%   tr.
%       type:   Current trial type (1=L, 2=R)
%       type2:  trial type including the previous trial 
%               (11=LL, 12=LR, 21=RL, 22=RR)
% 
% Takuma Kitanishi, OCU, 2018/07/18
%   last modified 2019/12/24

clear; 
close all;
fclose all;

mainfunc('tk0056','171014','06')
mainfunc('tk0056','171015','06')

mainfunc('tk0062','171129','06')
mainfunc('tk0062','171130','06')

mainfunc('tk0064','180206','06')
mainfunc('tk0064','180207','06')

mainfunc('tk0067','180426','07')
mainfunc('tk0067','180427','07')

mainfunc('tk0068','180530','07')
mainfunc('tk0068','180531','07')

mainfunc('tk0069','180726','07')
mainfunc('tk0069','180727','07')

mainfunc('tk0070','180829','07')
mainfunc('tk0070','180830','07')

mainfunc('tk0072','181025','07')
mainfunc('tk0072','181026','07')

mainfunc('tk0074','181219','07')
mainfunc('tk0074','181220','07')

mainfunc('tk0075','190326','07')
mainfunc('tk0075','190327','07')

mainfunc('tk0076','190424','07')
mainfunc('tk0076','190425','07')

ratemapT_stack()

% run('ratemapT_sum.m')
run('ratemapT_sum2.m')

sendmail2me


function mainfunc(rat,day,sess)

% config 
savePath = 'D:\data\rec\06T\ratemap';
basePath = fullfile('D:\data\rec',rat,[day '-' sess]);
spkpath  = fullfile('D:\data\rec\',rat,[day '_sorted']);
sessName = [rat '-' day '-' sess];
p = configT(basePath);

% number of shuffling
p.nshuff = 100;

% load pos (cm)
[post,posx1,posy1] = loadWhl(basePath,p.pixel2cm);
fsBehav = 1/(post(2)-post(1)); % behavior sampling freq (Hz)

% velocity (cm/s)
w = gausswin(11)/sum(gausswin(11));
xsm = conv(posx1,w,'same');
ysm = conv(posy1,w,'same');
v = conv( sqrt(gradient(xsm).^2+gradient(ysm).^2)*fsBehav, w,'same');

% trim and center data
idx = p.trange(1)<=post & post<p.trange(2);
post  = post(idx)-p.trange(1);
v = v(idx);


%% linearlized pos btwn 0-1

load(fullfile(savePath,[sessName '_trialDef.mat']),'pos','state','trial','n')

% construct trial information (including both L and R trials)
for ii=1:n(1)
    ind1(ii) = find(state==1 & trial==ii,1);          % start index
    ind2(ii) = find(state==1 & trial==ii,1,'last');   % end index
    type(ii) = 1;
end
for ii=1:n(2)
    ind1(n(1)+ii) = find(state==2 & trial==ii,1); 
    ind2(n(1)+ii) = find(state==2 & trial==ii,1,'last'); 
    type(n(1)+ii) = 2;
end

[~,sortidx] = sort(ind1);
tr.ind   = [ind1(sortidx)' ind2(sortidx)'];     % trial start/end position index
tr.t     = post(tr.ind);                        % trial start/end time
tr.type  = type(sortidx)';                      % current trial type (1=L, 2=R)

% trial type including the previous trial
% 11=LL, 12=LR, 21=RL, 22=RR
tr.type2 = [nan; tr.type(1:end-1)*10+tr.type(2:end)];

% correct/error trials
tr.corr = nan(length(tr.type),1);
for ii=2:length(tr.type)
    if ii==1
        tr.corr(ii) = nan;
        continue;
    end
    if tr.type(ii) ~= tr.type(ii-1)
        tr.corr(ii) = true;
    else
        tr.corr(ii) = false;
    end
end

tr1 = tr.type==1;
tr2 = tr.type==2;
tr11 = tr.type2==11;
tr12 = tr.type2==12;
tr21 = tr.type2==21;
tr22 = tr.type2==22;


%% load spike timing (sec)

[ts,clu,cluOri,Fs,roi,sh,ch]=loadSpkHist(spkpath,[],sessName);
idx = p.trange(1)<ts & ts<p.trange(2);
ts = ts(idx)-p.trange(1);
clu = clu(idx);
cluOri = cluOri(idx);

% spike position
idx = round((ts-post(1))*fsBehav)+1;
idx(idx==0) = 1;
idx(idx>length(pos)) = length(pos);
spkpos = pos(idx);


%% load 1250-Hz lfp
[lfp,t,~] = loadLfp(basePath,p.trange);
t = t-p.trange(1);
fsLfp = 1/(t(2)-t(1));

% load channel map
load('Buzsaki256.mat','chanMap0indMatrix')
chanmap = chanMap0indMatrix(:)+1;

% sort and select lfp channel
lfp = lfp(chanmap,:);
lfp = lfp(p.refch,:);

% theta phase/amplitude
theta = fftbandpass(lfp,1250,4,5,10,11);
z = hilbert(theta);
thPhase = angle(z(:))+pi;
thAmp = abs(z(:));

% find spike theta phase
idx = round((ts-t(1))*fsLfp+1);
idx(idx==0) = 1;
spkph = thPhase(idx);


%% velocity map (cm/s)

vMap = vmap(v, post, pos, tr.t, p.nbin);
tr.vmap = vMap;

% plot
clims = [ 0 ceil(max(tr.vmap(:)))+10 ];
posedges = 0:1/p.nbin:1;
posaxis = (posedges(1:end-1)+posedges(2:end))/2;
p.posaxis = posaxis;

figure(1); clf;
subplot(311)
imagesc(posaxis,1:n(1),vMap(tr1,:),clims)
colorbar; ylabel('Left trial')
title(sprintf('Velocity map (cm/s): %s',sessName))

subplot(312)
imagesc(posaxis,1:n(2),vMap(tr2,:),clims)
colorbar; ylabel('Right trial')

subplot(313)
v1 = mean(vMap(tr1,:),'omitnan'); 
v2 = mean(vMap(tr2,:),'omitnan'); 
ve1 = std(vMap(tr1,:),'omitnan')/sqrt(n(1));
ve2 = std(vMap(tr2,:),'omitnan')/sqrt(n(2));

yMax = ceil(max([4 v1+ve1 v2+ve2]))+10;
plot([p.b(1) p.b(1)],[0 yMax],'k:',[p.b(2) p.b(2)],[0 yMax],'k:',[p.b(3) p.b(3)],[0 yMax],'k:'); hold on
plotshaded(posaxis,[v1-ve1; v1; v1+ve1],'b');
plotshaded(posaxis,[v2-ve2; v2; v2+ve2],'r');
ylim([0 yMax])
xlabel('Linearized position (blue=left, red=right)'); ylabel('Velocity (cm/s)')
colorbar; box off

% save
imname1 = [sessName '_v'];
print(gcf,fullfile(savePath,imname1),'-dpng')
print(gcf,fullfile(savePath,imname1),'-dsvg')


%% time occupancy map (tMap1, tMap2)

tMap = tmap(post, pos, tr.t, p.nbin, fsBehav);
tr.tmap = tMap;


%% rate map

disp('Calculating rate maps...')

for ii=1:max(clu)
    switch roi(ii)
        case 1
            u(ii).roiName= 'SUB';
        case 3 
            u(ii).roiName= 'CA1';
        case 4
            u(ii).roiName= 'DG';
        otherwise
            u(ii).roiName= 'na';
    end
end

w = gausswin(7)'/sum(gausswin(7));

idxBox  = p.bBox(1)<posaxis & posaxis<p.bBox(2);
idxStem = p.bStem(1)<posaxis & posaxis<p.bStem(2);
idxArm  = p.bArm(1)<posaxis & posaxis<p.bArm(2);

for ii=1:max(clu)
    % for this unit
    spkposTmp = spkpos(clu==ii);
    spkphTmp = spkph(clu==ii);
    tsTmp = ts(clu==ii);
 
    % spike number map (each trial)
    u(ii).nspk = spkmap(tsTmp,spkposTmp,tr.t,p.nbin);
    
    % ratemap (each trilal)
    u(ii).rate = conv2(u(ii).nspk,w,'same')./conv2(tMap,w,'same');
    
    % mean & sem of ratemap along lineartrack
    u(ii).r(1,:) = mean(u(ii).rate(tr1,:),1,'omitnan');
    u(ii).r(2,:) = mean(u(ii).rate(tr2,:),1,'omitnan');
    
    u(ii).e(1,:) = std(u(ii).rate(tr1,:),1,'omitnan')/sqrt(n(1));    
    u(ii).e(2,:) = std(u(ii).rate(tr2,:),1,'omitnan')/sqrt(n(2));

    % map statistics
    pospdf1 = mean(tMap(tr1,:)) ./ sum(mean(tMap(tr1,:)));  % probability density map
    pospdf2 = mean(tMap(tr2,:)) ./ sum(mean(tMap(tr2,:)));
    [u(ii).all.meanRate(1),u(ii).all.Isec(1),u(ii).all.Ispk(1),u(ii).all.sparsity(1),u(ii).all.selectivity(1)] = mapstat(u(ii).r(1,:),pospdf1);
    [u(ii).all.meanRate(2),u(ii).all.Isec(2),u(ii).all.Ispk(2),u(ii).all.sparsity(2),u(ii).all.selectivity(2)] = mapstat(u(ii).r(2,:),pospdf2);
    
    % peakrate
    r1 = u(ii).r(1,:);
    r2 = u(ii).r(2,:);
    u(ii).all.peakRate      = [max(r1) max(r2)];
    
    % firing rate in the box (split by equal length time bins)
    % for each trial
    for jj=1:size(tr.t,1)
        % box start/end timing
        idx = tr.t(jj,1)<=post & post<=tr.t(jj,2) & p.bBox(1)<=pos & pos<=p.bBox(2);
        t1 = post(find(idx,1));
        t2 = post(find(idx,1,'last'));
        
        tedge = linspace(t1,t2,p.nbinbox+1);
        tbin = tedge(2)-tedge(1);
        % for each time bin
        u(ii).box.rate(jj,:) = histcounts(tsTmp,tedge) / tbin;
    end
    
    % spatially-binned firing rate in the stem
    % for each trial
    indSt = find(idxStem,1);
    indEnd = find(idxStem,1,'last');
    binsz = round(sum(idxStem)/p.nbinstem);
    for jj=1:p.nbinstem
        if jj<size(tr.t,1)
            ind1 = indSt+binsz*(jj-1);
            ind2 = ind1+binsz-1;
        else
            ind1 = indSt+binsz*(jj-1);
            ind2 = indEnd;
        end
        
        u(ii).stem.rate(:,jj) = mean(u(ii).rate(:,ind1:ind2),2);
    end
    
    % peak rate for each trial in each pos
    u(ii).box.peakRate  = max(u(ii).rate(:,idxBox),[],2);
    u(ii).stem.peakRate = max(u(ii).rate(:,idxStem),[],2);
    u(ii).arm.peakRate  = max(u(ii).rate(:,idxArm),[],2);

    % startbox mean rate change (0 to 1)
    u(ii).box.meanRate = sum(u(ii).nspk(:,idxBox),2)./sum(tMap(:,idxBox),2);
    m1all = sum(u(ii).nspk(tr1,idxBox),2)./sum(tMap(tr1,idxBox),2);
    m2all = sum(u(ii).nspk(tr2,idxBox),2)./sum(tMap(tr2,idxBox),2);
    m1 = mean(m1all);
    m2 = mean(m2all);
    u(ii).box.meanRatePval = ranksum(m1all,m2all);
    u(ii).box.meanRateChange = abs(m1-m2) / max([m1 m2]);

    % startbox peak rate change
    p1all = max(u(ii).rate(tr1,idxBox),[],2);
    p2all = max(u(ii).rate(tr2,idxBox),[],2);
    u(ii).box.peakRatePval = ranksum(p1all,p2all);
    p1 = max(u(ii).r(1,idxBox));
    p2 = max(u(ii).r(2,idxBox));
    u(ii).box.peakRateChange = abs(p1-p2) / max([p1 p2]);
    
    % auROC analysis to discriminate L/R trials
    [~,~,~,AUC] = perfcurve(tr.type, u(ii).box.meanRate,1);
    if AUC<0.5
        AUC = 1-AUC;
    end
    u(ii).box.meanRateAuROC = AUC;
    
    % startbox trajectory information (bits/spk), (bits/sec)
    pdf = sum(tr.type==1:2)./length(tr.type);
    x = u(ii).box.meanRate;
    rate = [mean(x(tr.type==1)) mean(x(tr.type==2))];
    meanrate = mean(x);
    u(ii).box.Isec = sum(rate .* log2(rate/meanrate) .* pdf);
    u(ii).box.Ispk = sum(rate .* log2(rate/meanrate) .* pdf ./ meanrate);
    u(ii).box.meanrate = meanrate;
    
    % shuffled information & auROC
    trtype = tr.type;
    for jj=1:p.nshuff
        trtypeShuff = trtype(randperm(length(trtype)));
        
        % pdf = sum(trtypeShuff==1:2)./length(trtypeShuff);
        % x = u(ii).box.meanRate;
        rateShuff = [mean(x(trtypeShuff==1)) mean(x(trtypeShuff==2))];
        % meanrate = mean(x);
        u(ii).box.IsecShuff(jj) = sum(rateShuff .* log2(rateShuff/meanrate) .* pdf);
        u(ii).box.IspkShuff(jj) = sum(rateShuff .* log2(rateShuff/meanrate) .* pdf ./ meanrate);
        
        % auROC
        [~,~,~,AUCshuff] = perfcurve(trtypeShuff, u(ii).box.meanRate,1);
        if AUCshuff<0.5
            AUCshuff = 1-AUCshuff;
        end
        u(ii).box.meanRateAuROCshuff(jj) = AUCshuff;
    end
    
    % stem mean rate change (0 to 1)
    u(ii).stem.meanRate = sum(u(ii).nspk(:,idxStem),2)./sum(tMap(:,idxStem),2);
    m1all = sum(u(ii).nspk(tr1,idxStem),2)./sum(tMap(tr1,idxStem),2);
    m2all = sum(u(ii).nspk(tr2,idxStem),2)./sum(tMap(tr2,idxStem),2);
    m1 = mean(m1all);
    m2 = mean(m2all);
    u(ii).stem.meanRatePval = ranksum(m1all,m2all);
    u(ii).stem.meanRateChange = abs(m1-m2) / max([m1 m2]);
    
    % stem peak rate change
    p1all = max(u(ii).rate(tr1,idxStem),[],2);
    p2all = max(u(ii).rate(tr2,idxStem),[],2);
    u(ii).stem.peakRatePval = ranksum(p1all,p2all);
    p1 = max(u(ii).r(1,idxStem));
    p2 = max(u(ii).r(2,idxStem));
    u(ii).stem.peakRateChange = abs(p1-p2) / max([p1 p2]);
    
    % stem auROC
    [~,~,~,AUC] = perfcurve(tr.type, u(ii).stem.meanRate,1);
    if AUC<0.5
        AUC = 1-AUC;
    end
    u(ii).stem.meanRateAuROC = AUC;
    
    % stem trajectory information (bits/spk), (bits/sec)
    pdf = sum(tr.type==1:2)./length(tr.type);
    x = u(ii).stem.meanRate;
    rate = [mean(x(tr.type==1)) mean(x(tr.type==2))];
    meanrate = mean(x);
    u(ii).stem.Isec = sum(rate .* log2(rate/meanrate) .* pdf);
    u(ii).stem.Ispk = sum(rate .* log2(rate/meanrate) .* pdf ./ meanrate);
    u(ii).stem.meanrate = meanrate;
    
    % stem shuffled information
    trtype = tr.type;
    for jj=1:p.nshuff
        trtypeShuff = trtype(randperm(length(trtype)));
        
        % pdf = sum(trtypeShuff==1:2)./length(trtypeShuff);
        % x = u(ii).box.meanRate;
        rateShuff = [mean(x(trtypeShuff==1)) mean(x(trtypeShuff==2))];
        % meanrate = mean(x);
        u(ii).stem.IsecShuff(jj) = sum(rateShuff .* log2(rateShuff/meanrate) .* pdf);
        u(ii).stem.IspkShuff(jj) = sum(rateShuff .* log2(rateShuff/meanrate) .* pdf ./ meanrate);
        
        % auROC
        [~,~,~,AUCshuff] = perfcurve(trtypeShuff, u(ii).stem.meanRate,1);
        if AUCshuff<0.5
            AUCshuff = 1-AUCshuff;
        end
        u(ii).stem.meanRateAuROCshuff(jj) = AUCshuff;
    end
    
    % peak rate change at arm
    p1 = max(u(ii).r(1,idxArm));
    p2 = max(u(ii).r(2.,idxArm));
    u(ii).arm.peakRateChange = abs(p1-p2) / max([p1 p2]);
    
    % map correlation
    r = corrcoef(u(ii).r(1,idxStem),u(ii).r(2,idxStem));
    u(ii).stem.r = r(2);
    
    r = corrcoef(u(ii).r(1,idxArm),u(ii).r(2,idxArm));
    u(ii).arm.r = r(2);
    
    
    % plot ratemap
    clims = [ 0 ceil(max([5 prctile(u(ii).rate(:),99)]))+1 ];
    
    figure(2); clf
    set(gcf,'OuterPosition',[56 0 900 1200]);
    
    subplot(6,3,[1 2])
    imagesc(posaxis,[],u(ii).rate(tr21,:),clims); colorbar
    ylabel('Correct left')
    title(sprintf('%s unit %u (%s)',sessName,ii,u(ii).roiName))
    
    subplot(6,3,[4 5])
    imagesc(posaxis,[],u(ii).rate(tr12,:),clims); colorbar
    ylabel('Correct right')
    
    subplot(6,3,[7 8])
    imagesc(posaxis,[],u(ii).rate(tr11,:),clims); colorbar
    ylabel('Error left')
    
    subplot(6,3,[10 11])
    imagesc(posaxis,[],u(ii).rate(tr22,:),clims); colorbar
    ylabel('Error right')
    
    subplot(6,3,[13 14]);
    plotshadedWrap(u(ii).rate(tr21,:),posaxis,'b');
    plotshadedWrap(u(ii).rate(tr12,:),posaxis,'r'); hold on
    plotshadedWrap(u(ii).rate(tr11,:),posaxis,[.6 .6 1]);
    plotshadedWrap(u(ii).rate(tr22,:),posaxis,[1 .6 .6]); hold on
    yLim = get(gca,'YLim');
    plot([p.b(1) p.b(1)],yLim,'k:',[p.b(2) p.b(2)],yLim,'k:',[p.b(3) p.b(3)],yLim,'k:');
    colorbar; box off;
    title('Correct left (blue), right (red)')
    xlabel('Normalized position')
    ylabel('Firing rate (Hz)')
    
    
    subplot(6,3,3); imagesc(u(ii).box.rate(tr21,:),clims); colorbar; title('Time bin in box')
    subplot(6,3,6); imagesc(u(ii).box.rate(tr12,:),clims); colorbar
    subplot(6,3,9); imagesc(u(ii).box.rate(tr11,:),clims); colorbar
    subplot(6,3,12);imagesc(u(ii).box.rate(tr22,:),clims); colorbar
    
    subplot(6,3,15);
    plotshadedWrap(u(ii).box.rate(tr21,:),1:p.nbinbox,'b');
    plotshadedWrap(u(ii).box.rate(tr12,:),1:p.nbinbox,'r'); hold on
    plotshadedWrap(u(ii).box.rate(tr11,:),1:p.nbinbox,[.6 .6 1]);
    plotshadedWrap(u(ii).box.rate(tr22,:),1:p.nbinbox,[1 .6 .7]); hold on
    xlim([.5 p.nbinbox+.5])
    ylim(yLim)
    colorbar; box off; drawnow;
%     xlabel('Time bin in box')
    ylabel('Firing rate (Hz)')
    
    % theta phase precession
    phbins = linspace(0,1,13)*2*pi;
    phaxis = (phbins(1:end-1)+phbins(2:end))/2;
    
    % left trial
    t1all = tr.t(tr1,:);
    for j=1:size(t1all,1)
        % trial start/end timing (sec)
        t1 = t1all(j,1);
        t2 = t1all(j,2);
        % cumulative spike pos
        if j==1
            x1 = spkposTmp(t1<tsTmp & tsTmp<t2);
            y1 = spkphTmp(t1<tsTmp & tsTmp<t2);
        else
            x1 = [x1; spkposTmp(t1<tsTmp & tsTmp<t2)];
            y1 = [y1; spkphTmp(t1<tsTmp & tsTmp<t2)];
        end
    end
    % right trial
    t2all = tr.t(tr2,:);
    for j=1:size(t2all,1)
        % trial start/end timing (sec)
        t1 = t2all(j,1);
        t2 = t2all(j,2);
        % cumulative spike pos
        if j==1
            x2 = spkposTmp(t1<tsTmp & tsTmp<t2);
            y2 = spkphTmp(t1<tsTmp & tsTmp<t2);
        else
            x2 = [x2; spkposTmp(t1<tsTmp & tsTmp<t2)];
            y2 = [y2; spkphTmp(t1<tsTmp & tsTmp<t2)];
        end
    end
    % phase histogram
    phcounts1 = hist(y1,phaxis);
    phcounts2 = hist(y2,phaxis);
    maxcount = max([phcounts1(:);phcounts2(:)]);
    
    % plot
    subplot(6,8,[41 43])
    plot([x1; x1],[y1; y1+2*pi],'b.'); hold on
    plot([p.b(1) p.b(1)],[0 4*pi],'k:',[p.b(2) p.b(2)],[0 4*pi],'k:',[p.b(3) p.b(3)],[0 4*pi],'k:');
    ylim([0 4*pi]); box off
    yticks([0 pi 2*pi 3*pi 4*pi])
    yticklabels({'0','\pi','2\pi','3\pi','4\pi'})
    xlabel('Linearized position (left trial)'); 
    ylabel('Theta phase')
    
    subplot(6,8,44)
    barh([phaxis phaxis+2*pi],[phcounts1 phcounts1],1,'FaceColor',[.5 .5 .5]);
    xlim([0 maxcount+10])
    ylim([0 4*pi]); box off
    xlabel('Spike counts')
    yticks([0 pi 2*pi 3*pi 4*pi])
    yticklabels({'0','\pi','2\pi','3\pi','4\pi'})
    
    subplot(6,8,[45 47])
    plot([x2; x2],[y2; y2+2*pi],'r.'); hold on
    plot([p.b(1) p.b(1)],[0 4*pi],'k:',[p.b(2) p.b(2)],[0 4*pi],'k:',[p.b(3) p.b(3)],[0 4*pi],'k:');
    ylim([0 4*pi]); box off
    yticks([0 pi 2*pi 3*pi 4*pi])
    yticklabels({'0','\pi','2\pi','3\pi','4\pi'})
    xlabel('Linearized position (right trial)'); 
    
    subplot(6,8,48)
    barh([phaxis phaxis+2*pi],[phcounts2 phcounts2],1,'FaceColor',[0.5 0.5 0.5]);
    xlim([0 maxcount+10])
    ylim([0 4*pi]); box off
    xlabel('Spike counts')
    yticks([0 pi 2*pi 3*pi 4*pi])
    yticklabels({'0','\pi','2\pi','3\pi','4\pi'})
    
    colormap jet
    drawnow
    
    imname2 = [sessName '_u' num2str(ii)];
    print(gcf,fullfile(savePath,imname2),'-dpng')
    % print(gcf,fullfile(savePath,imname2),'-dsvg')
end

save(fullfile(savePath,sessName),'u','tr','sessName','p')

end

function ratemapT_stack()

matPath = 'D:\data\rec\06T\ratemap';
savePath ='D:\data\rec\06T\ratemap';

% get mat file list
matList = dir(fullfile(matPath,'tk*.mat'));

% remove '_trialDef.mat'
remFlag = false(size(matList));
for ii=1:length(matList)
    if contains(matList(ii).name,'_trialDef.mat')
        remFlag(ii) = true;
    end
end
matList(remFlag) = [];

    
%% stack results

fprintf('%u mat files found.\n',length(matList))

uall = [];
trall=[];
for ii=1:length(matList)
    fprintf('Stacking: %s\n',matList(ii).name)
    
    load(fullfile(matList(ii).folder,matList(ii).name),'u','tr','sessName','p')
    
    % stack 'u'
    % add session and unit num
    for jj=1:length(u)
        u(jj).session = sessName;
        u(jj).unit = jj;
    end
    % reorder field names and stack fields
    nField = length(fieldnames(u));
    perim = [nField-1 nField 1:nField-2];
    
    uall =[uall, orderfields(u,perim)];
    
    % stack 'tr'
    sess_Name = strrep(sessName,'-','_');
    
    trall.(sess_Name).tr = tr;
    trall.(sess_Name).p  = p;
end

% save
save(fullfile(savePath,'ratemapT.mat'),'uall','trall')

end



%% ---------------------------------------------------------------
% functions
% -------------------------------------------------------------------------

function plotshadedWrap(rate,posaxis,c)

r = mean(rate,1);
e = std(rate,[],1)./sqrt(size(rate,1));

% delete below zero
r1 = r-e;
r1(r1<0) = 0;

plotshaded(posaxis,[r1; r; r+e],c);

end

% Shannon information, sparseness, and selectivity
function [meanrate,infoPerSec,infoPerSpk,sparsity,selectivity] = mapstat(map,pospdf)

% peakrate = nanmax(map(:));
meanrate = nansum(nansum( map .* pospdf ));
meansquarerate = nansum(nansum( (map.^2) .* pospdf ));

% sparsity
if meansquarerate == 0
    sparsity = NaN;
else
    sparsity = meanrate^2 / meansquarerate;
end

% selectivity
maxrate = max(max(map));
if meanrate == 0
    selectivity = NaN;
else
    selectivity = maxrate/meanrate;
end

% Shannon information
%   infoPerSec, information (bits/sec)
%   infoPerSpk, information (bits/spike)
% Advances in Neural Information Processing Systems 1993. An information-theoretic approach to deciphering the Hippocampal code
[i1, i2] = find( (map>0) & (pospdf>0) );  % the limit of x*log(x) as x->0 is 0
if ~isempty(i1)
    akksum = 0;
    for i = 1:length(i1)
        ii1 = i1(i);
        ii2 = i2(i);
        akksum = akksum + pospdf(ii1,ii2) * (map(ii1,ii2)) * log2( map(ii1,ii2) / meanrate );
    end
    infoPerSec= akksum;
else
    infoPerSec = NaN;
end

if meanrate == 0
    infoPerSpk = NaN;
else
    infoPerSpk = infoPerSec./meanrate;
end

end


% spike number map (sec)
function nspk = spkmap(tsTmp,spkposTmp,trt,nbin)

n = size(trt,1);
nspk = nan(n,nbin);    % spike number map [trial bin]

for jj=1:n
    % trial start/end timing (sec)
    t1 = trt(jj,1);
    t2 = trt(jj,2);
    % spike pos
    spkposTmp2 = spkposTmp(t1<tsTmp & tsTmp<t2);
    for kk=1:nbin
        nspk(jj,kk) = sum(1/nbin*(kk-1)<spkposTmp2 & spkposTmp2<=1/nbin*kk);
    end
end

end

% % spike number map (sec)
% function nspk = spkmap(tsTmp,spkposTmp,post,state,stateIdx,trial,n,nbin)
% 
% nspk = nan(n,nbin);    % spike number map [trial bin]
% for jj=1:n
%     % trial start/end timing (sec)
%     t1 = min(post(state==stateIdx & trial==jj));
%     t2 = max(post(state==stateIdx & trial==jj));
%     % spike pos
%     spkposTmp2 = spkposTmp(t1<tsTmp & tsTmp<t2);
%     for kk=1:nbin
%         nspk(jj,kk) = sum(1/nbin*(kk-1)<spkposTmp2 & spkposTmp2<=1/nbin*kk);
%     end
% end
% 
% end


% time occupancy map (sec)
function tMap = tmap(post,pos,trt,nbin,fsBehav)

n = size(trt,1);
tMap = nan(n,nbin); 

% for each trial
for jj=1:n(1)
    % trial start/end timing (sec)
    t1 = trt(jj,1);
    t2 = trt(jj,2);
    % animal pos
    posTmp = pos(t1<=post & post<t2);
    for kk=1:nbin
        tMap(jj,kk) = sum(1/nbin*(kk-1)<posTmp & posTmp<=1/nbin*kk) /fsBehav;
    end
end

end

% % time occupancy map (sec) (old)
% function tMap = tmap(post,state,stateIdx,trial,n,pos,nbin,fsBehav)
% 
% tMap = nan(n,nbin); 
% 
% % for each trial
% for jj=1:n(1)
%     % trial start/end timing (sec)
%     t1 = min(post(state==stateIdx & trial==jj));
%     t2 = max(post(state==stateIdx & trial==jj));
%     % animal pos
%     posTmp = pos(t1<=post & post<t2);
%     for kk=1:nbin
%         tMap(jj,kk) = sum(1/nbin*(kk-1)<posTmp & posTmp<=1/nbin*kk) /fsBehav;
%     end
% end
% 
% end

% velocity map
% v,    running speed
% post, position time stamp
% trt,  trial start/end time
% pos,  linearlized pos
% nbin, number of bins
function vMap = vmap(v,post,pos,trt,nbin)

n = size(trt,1);
vMap = nan(n,nbin);

% for each trial
for jj=1:n
    % trial start/end timing (sec)
    t1 = trt(jj,1);
    t2 = trt(jj,2);
    for kk=1:nbin
        vMap(jj,kk) = mean(v( (t1<=post & post<t2) & (1/nbin*(kk-1)<pos & pos<=1/nbin*kk) ));
    end
end

end

% velocity map (old)
% function vMap = vmap(v,post,state,stateIdx,trial,n,pos,nbin)
% 
% vMap = nan(n,nbin);
% 
% % for each trial
% for jj=1:n
%     % trial start/end timing (sec)
%     t1 = min(post(state==stateIdx & trial==jj));
%     t2 = max(post(state==stateIdx & trial==jj));
%     for kk=1:nbin
%         vMap(jj,kk) = mean(v( (t1<=post & post<t2) & (1/nbin*(kk-1)<pos & pos<=1/nbin*kk) ));
%     end
% end
% 
% end


% [pos,state,trial,n] = linearize(x,y,'plot')
% 
% Linearize t-maze behavior tracking along reference lines. Requires
% interparc.m.
% 
% INPUT
%   x,y:    animal position x,y (cm)
%   plot:   (optional) plot images for checking results
% OUTPUT
%   pos:    linearlized position between 0-1 [size(x)]
%   state:  state (nan=undefined, 1=left trail, 2=right trial) [size(x)]
%   trial:  trial number [size(x)]
%           (state==1 & trial==n) gives n-th trial index
%   n:      number of trials, n(1)=left trials, n(2), right trials
%   p:      params for defining reference lines
% 
% Takuma Kitanishi, OCU, 2018

function [pos,state,trial,n] = linearize(x,y,varargin)

% reference line setting --------------------------------------------------
p.xref1 = [-20 -5   0  0 -5 -52 -57 -57 -52   -20];
p.yref =  [-54 -54 -49 56 61  61  56 -49 -54 -54];
p.xref2 = -p.xref1;
% p.boxrange = [0.95 0.03];
p.nrefpoints = 1000;
% -------------------------------------------------------------------------

% if 1
%     figure(1);clf
%     plot(x,y,'k',p.xref1,p.yref,'r',p.xref2,p.yref,'r')
% end

% interporate reference lines into 1000 points
t = 0:1/p.nrefpoints:1-1/p.nrefpoints;
[pt1,~,~] = interparc(t, p.xref1, p.yref, 'linear');
[pt2,~,~] = interparc(t, p.xref2, p.yref, 'linear');
xref1 = pt1(:,1);
yref  = pt1(:,2);
xref2 = pt2(:,1);

% find the linearized pos by measuring the distance between ref line and
% actual data points
X = repmat(x(:),1,length(t));
Y = repmat(y(:),1,length(t));
Xref1 = repmat(xref1(:)',length(x),1);
Xref2 = repmat(xref2(:)',length(x),1);
Yref = repmat(yref(:)',length(x),1);

[d1,pos1] = min((X-Xref1).^2 + (Y-Yref).^2,[],2);
[d2,pos2] = min((X-Xref2).^2 + (Y-Yref).^2,[],2);
pos1 = pos1/length(t);
pos2 = pos2/length(t);

% linearlized position (temporary)
pos = nan(size(x));
pos(d1==d2) = pos1(d1==d2);
pos(d1<d2) = pos1(d1<d2);
pos(d1>d2) = pos2(d1>d2);

% determine left/right trials
state  = nan(size(x));
state(d1<d2) = 1;      % left trials
state(d1>d2) = 2;      % right trials
% state(p.boxrange(1)<pos | pos<p.boxrange(2)) = 0;  % waiting box
% extend LR trials backward to pos 0
idx = length(state);
while idx>0
    if 0.5<pos(idx) && pos(idx)<0.6
        currLR = state(idx);
        while idx>0 && pos(idx)<0.6
            state(idx) = currLR;
            idx = idx-1;
        end
    else
        idx = idx-1;
    end
end
% remove labels for jump between 1 and 0
idx = 1;
while idx<=length(state)
    if 0.5<pos(idx) && pos(idx)<0.6
        currLR = state(idx);
        while idx<=length(state) && pos(idx)>0.1
            idx = idx+1;
        end
        
        tf = false(size(pos));
        tf(idx+1:end)=true;
        idx2 = find(0.5<pos & pos<0.6 & tf,1);
        while pos(idx2)<0.6
            idx2=idx2-1;
        end
        % update state
        if idx2>idx
            state(idx:idx2)=nan;
        end
        idx = idx+1;
    else
        idx = idx+1;
    end
end
% remove fragmented labels at the end of session
idx = length(state);
while pos(idx)<0.6
    state(idx)=nan;
    idx = idx-1;
end

% remove short fragments less than 1 sec (= 40 data points)
% transIdx = find(diff(state));
% fragLength = diff(transIdx);
% shortFrag = find(fragLength<40);
% for ii=1:length(shortFrag)
%     state(transIdx(shortFrag(ii))+1:transIdx(shortFrag(ii)+1)) = state(transIdx(shortFrag(ii)));
% end

% update linearized pos at stem end point
pos(state==1 & 0.3<pos & pos<0.5) = pos1(state==1 & 0.3<pos & pos<0.5);
pos(state==2 & 0.3<pos & pos<0.5) = pos2(state==2 & 0.3<pos & pos<0.5);

% trial count for left/right trials
trial = nan(size(state));
for searchState=1:2
    currTrial=1;
    trial(find(state==searchState,1)) = currTrial;
    idx = find(state==searchState,1)+1;
    while idx<=length(state)
        if state(idx)==searchState && pos(idx-1)-pos(idx)>0.8
            % new trial
            currTrial = currTrial+1;
            trial(idx) = currTrial;
        elseif state(idx)==searchState && state(idx-1)==searchState
            % same trial
            trial(idx) = trial(idx-1);
        end
        idx = idx+1;
    end
end

% number of trials for LR trials
for currState=1:2
    n(currState) = max(trial(state==currState));
end

% plot for check
if nargin==3
    figure(99); clf
    plot(x,y,'Color',[0.5 0.5 0.5]); hold on
    plot(xref1,yref,'r',xref2,yref,'r'); hold on
    for ii=1:20
        r = ii/20;
        xTmp = xref1(round(r*p.nrefpoints));
        yTmp = yref(round(r*p.nrefpoints));
        plot(xTmp,yTmp,'.r')
        if mod(ii,2)==0
            text(xTmp,yTmp,sprintf('%s%.1f','\leftarrow',r),'Color','r');
        end
    end
    axis equal
    
    figure(98); clf
    ind = 1:length(pos);
    plot(ind,pos,'Color',[0.5 0.5 0.5]); hold on
    plot(ind(state==1),pos(state==1),'b.')
    plot(ind(state==2),pos(state==2),'r.')
    % legend({'Track','Start box','Left','Right'})
    xlabel('Tracking points')
    ylabel('Linearized pos')
    title(sprintf('Number of trials, L= %u , R= %u',n(1),n(2)))
    ylim([-0.1 1.1])
    
    drawnow;
end

end
